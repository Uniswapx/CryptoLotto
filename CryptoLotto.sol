/*********************************************
Crypto Lotto
Fully Transparent Crypto based Lottery
Official github
https://github.com/AllCoinLab/CryptoLotto
All code is more focused on easy syntax
in order to make all people to check and verify this is SAFU
Take a look around and if you feel this is safe,
join the lotto :)
All the code is generated by myself
*********************************************/

// Code Rule
// 1. Easy to check so easily checked and verified by the users
// 2. Efficient to lower the transaction fee
// 3. No need to be strictly optimal as it is very time-consuming

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.2;

contract lotto {
    address public lotto_moderator;
    uint public mod_fee;
    
    uint public max_ticket_id;
    uint private start_ticket_id;
    
    struct TICKET {
        uint tot_id;
        uint id;
    }
    mapping (address => TICKET[]) public user2ids;
    address[] public id2user;
    
    // TODO: stacking rewards 
    // mapping (address => uint) public rewards;
    
    // TODO: emit winner event
    event WINNERS(address winner, uint id, uint prize);
    
    fallback() external payable {}
    receive() external payable {}
    
    constructor() {
        // it is me who moderate the lotto
        lotto_moderator = msg.sender;
    }
    
    //////////////////////////////////// views
    function get_ids(address user) external view returns (uint[] memory) {
        uint[] memory ids = new uint[](user2ids[user].length);
        if (user2ids[user].length == 0) { // no bets
            return ids;
        }

        for (uint i; i < ids.length; i++) {
            ids[i] = user2ids[user][i].id;
        }
        
        return ids;
    }
    
    function get_user(uint id) external view returns (address) {
        return id2user[id];
    }
    
    // maybe big load, erase if big
    // function get_users() external view returns (address[] memory) {
    //     return id2user;
    // }
    
    function get_tickets() external view returns (uint) {
        return max_ticket_id - start_ticket_id;
    }
    
    function get_total_tickets() external view returns (uint) {
        return max_ticket_id;
    }
    
    function get_prize() external view returns (uint) {
        return address(this).balance * (10000 - mod_fee) / 10000;
    }
    
    function get_random_number(uint seed, uint i) external view returns (uint) {
        if (id2user.length == 0) {
            return 0;
        }
        
        return uint(keccak256(abi.encode(seed, i, block.timestamp))) % id2user.length;
    }
    
    ///////////////////////////////////// mains
    function _bet() external payable {
        require(msg.sender != lotto_moderator, 'Rule 3: Mod will NEVER join');
        
        // check max
        require(msg.value < 3 * (10 ** 18), 'Bet count limit (TBD. Gas may be too high)');
        
        uint bet_unit = 10 ** 17;
        uint tickets = msg.value / bet_unit;
        
        for (uint i; i < tickets; i++) {
            TICKET memory ticket;
            ticket.tot_id = max_ticket_id + 1;
            ticket.id = id2user.length + 1;
            
            user2ids[msg.sender].push(ticket);
            id2user.push(msg.sender);
            max_ticket_id++;
        }
    }
    

    // ppl can get a specific id by setting gas
    // random id is calculated with seed + ts
    // so if someone want to match id with random id,
    // need to know the seed and the ts at the bet time
    // which is impossible
    
    // select among many random method
    // 1. manual execution with seed
    // v is random, ts is semi-random + unpredictable at bet time
    function get_winner(uint seed, uint n) external returns (uint[] memory) {
        require(msg.sender == lotto_moderator, 'Only mod can execute this');
        
        // get the winning number
        // Multiple ticket method
        // constant probability: 1 / N
        // duplicate selection permitted
        uint[] memory winner_id_cnts = new uint[](id2user.length);
        for (uint i; i < n; i++) {
            // simple but powerful multiple random number generator
            uint winner_id = uint(keccak256(abi.encode(seed, i, block.timestamp))) % id2user.length;
            winner_id_cnts[winner_id]++;
        }
        
        uint total_fund = address(this).balance;
        
        // distribute the prize
        uint total_prize = total_fund * (10000 - mod_fee) / 10000;
        for (uint id; id < id2user.length; id++) {
            if (winner_id_cnts[id] != 0) {
                uint prize = total_prize * winner_id_cnts[id] / n;
                payable(id2user[id]).transfer(prize);
                emit WINNERS(id2user[id], id, prize);
            }
        }
        
        {
            // mod process.
            uint mod_fund = total_fund * mod_fee / 10000;
            payable(lotto_moderator).transfer(mod_fund);
        }
        
        // almost all funds should be distributed at each draw
        
        // reset the bet
        uint id_len;
        for (uint id; id < id2user.length; id++) {
            id_len = user2ids[id2user[id]].length;
            delete user2ids[id2user[id]];
            id += id_len - 1;
        }
        delete id2user;
        start_ticket_id = max_ticket_id;
    }
    
    ///////////////////////////// mod
    function set_important_variables(uint _mod_fee) external {
        require(msg.sender == lotto_moderator, 'Only mod can set this');
        
        require(_mod_fee <= 500, 'Rule 4: NO MORE THAN 5% fee');
        mod_fee = _mod_fee; // fee will be divided by 10000
    }
}
