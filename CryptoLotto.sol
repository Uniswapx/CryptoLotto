/*********************************************
Crypto Lotto
Fully Transparent Crypto based Lottery

Official github
https://github.com/AllCoinLab/CryptoLotto

All code is more focused on easy syntax
in order to make all people to check and verify this is SAFU

Take a look around and if you feel this is safe,
join the lotto :)

All the code is generated by myself
*********************************************/

// Code Rule
// 1. Easy to check so easily checked and verified by the users
// 2. Efficient to lower the transaction fee
// 3. No need to be strictly optimal as it is very time-consuming

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.2;

contract lotto {
    address public lotto_moderator;
    uint public mod_fee;
    
    uint public tot_tickets_cnt;
    uint public start_ticket_id;
    
    struct TICKET {
        uint tot_id;
        uint id;
    }
    mapping (address => TICKET[]) public user2ids;
    address[] public id2user;
    
    // TODO: stacking rewards 
    // mapping (address => uint) public rewards;
    
    event WINNERS(address winner, uint id, uint prize);
    
    fallback() external payable {}
    receive() external payable {}
    
    constructor() {
        // it is me who moderate the lotto
        lotto_moderator = msg.sender;
        
        // set id 0 to be no one. only uses id 1+
        id2user.push(address(0x0000000000000000000000000000000000000000));
    }
    
    //////////////////////////////////// views
    function get_ids(address user) external view returns (uint[] memory) {
        uint[] memory ids = new uint[](user2ids[user].length);
        if (user2ids[user].length == 0) { // no bets
            return ids;
        }
           
        if (user2ids[user][user2ids[user].length - 1].tot_id < start_ticket_id) { // only previous bets. ignore them. will be erased at new bet
            return ids;
        }
            

        for (uint i; i < ids.length; i++) {
            ids[i] = user2ids[user][i].id;
        }
        
        return ids;
    }
    
    function get_user(uint id) external view returns (address) {
        return id2user[id];
    }
    
    // maybe big load, erase if big
    function get_users() external view returns (address[] memory) {
        return id2user;
    }
    
    ///////////////////////////////////// mains
    function _bet() external payable {
        require(msg.sender != lotto_moderator, 'Rule 3: Mod will NEVER join');
        
        // check max
        require(msg.value < 3 * (10 ** 18), 'Bet count limit (TBD. Gas may be too high)');
        
        uint bet_unit = 10 ** 17;
        uint tickets = msg.value / bet_unit;
        
        if (user2ids[msg.sender].length != 0) { // bet is not empty
            if (user2ids[msg.sender][user2ids[msg.sender].length - 1].tot_id < start_ticket_id) { // old bets. erase them
                delete user2ids[msg.sender];
            }
        }
        
        for (uint i; i < tickets; i++) {
            TICKET memory ticket;
            ticket.tot_id = tot_tickets_cnt;
            ticket.id = id2user.length;
            
            user2ids[msg.sender].push(ticket);
            id2user.push(msg.sender);
            tot_tickets_cnt++;
        }
    }
    

    // ppl can get a specific id by setting gas
    // random id is calculated with seed + ts
    // so if someone want to match id with random id,
    // need to know the seed and the ts at the bet time
    // which is impossible
    
    // select among many random method
    // 1. manual execution with seed
    // v is random, ts is semi-random + unpredictable at bet time
    function get_winner(uint seed, uint n) external returns (uint[] memory) {
        require(msg.sender == lotto_moderator, 'Only mod can execute this');
        
        // get the winning number
        // Multiple ticket method
        // constant probability: 1 / N
        // duplicate selection permitted
        uint[] memory winner_id_cnts = new uint[](id2user.length);
        for (uint i; i < n; i++) {
            // simple but powerful multiple random number generator
            uint winner_id = uint(keccak256(abi.encode(seed, i, block.timestamp))) % id2user.length + 1;
            winner_id_cnts[winner_id]++;
        }
        
        uint total_fund = address(this).balance;
        
        // distribute the prize
        uint total_prize = total_fund * (10000 - mod_fee) / 10000;
        for (uint id; id < id2user.length; id++) {
            if (winner_id_cnts[id] != 0) {
                uint prize = total_prize * winner_id_cnts[id] / n;
                payable(id2user[id]).transfer(prize);
                emit WINNERS(id2user[id], id, prize);
            }
        }
        
        {
            // mod process.
            uint mod_fund = total_fund * mod_fee / 10000;
            payable(lotto_moderator).transfer(mod_fund);
        }
        
        // almost all funds should be distributed at each draw
        
        // reset the bet
        start_ticket_id = tot_tickets_cnt;
        delete id2user;
    }
    
    ///////////////////////////// mod
    function set_important_variables(uint _mod_fee) external {
        require(msg.sender == lotto_moderator, 'Only mod can set this');
        
        require(_mod_fee <= 500, 'Rule 4: NO MORE THAN 5% fee');
        mod_fee = _mod_fee; // fee will be divided by 10000
    }
}
